<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>Canvas 绘制 CNN 结构图</title>
  <style>
    body { margin: 0; padding: 20px; background: #fff; }
    canvas { border: 1px solid #ccc; }
  </style>
</head>
<body>
<canvas id="cnnCanvas" width="780" height="240"></canvas>
<canvas id="cnnCanvas2" width="780" height="240"></canvas>
<canvas id="cnnCanvas3" width="780" height="240"></canvas>
<canvas id="cnnCanvas4" width="780" height="240"></canvas>
<canvas id="cnnCanvas5" width="780" height="250"></canvas>
<canvas id="cnnCanvas6" width="780" height="250"></canvas>
<canvas id="cnnCanvas7" width="780" height="250"></canvas>
<canvas id="cnnCanvas8" width="780" height="300"></canvas>
<canvas id="cnnCanvas9" width="780" height="250"></canvas>
<canvas id="cnnCanvas10" width="780" height="250"></canvas>
<canvas id="cnnCanvas11" width="780" height="250"></canvas>

<script> // 全局变量和可调用API
  // 样式参数
  const fm1Color = 'rgba(0,100,255,0.2)';
  const convStroke = '#0060ff';
  const fm2Color = 'rgba(128,123,255,0.2)';
  const poolStroke = '#aa00aa';
  const dashColor = '#333';
  const dashColor2 = '#ff0';

  // 绘制连线
  function drawConnector(ctx, fromX, fromY, toX, toY) {
    ctx.save();
    ctx.strokeStyle = dashColor;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = dashColor;
    ctx.fill();
    ctx.restore();
  }

  function drawConnectorReal(ctx, fromX, fromY, toX, toY) {
    ctx.save();
    ctx.strokeStyle = '#000';
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();
    ctx.restore();
  }

  // 绘制多层叠加的方块函数
  function drawLayer(ctx, x, y, w, h, count, offset, fill, stroke, AlpghaRate) {
    for (let i = 0; i < count; i++) {
      // 保存当前状态
      ctx.save();
      // 逐层降低透明度
      ctx.globalAlpha = (1 - i / (count)) * AlpghaRate;
      ctx.fillStyle   = fill;
      ctx.strokeStyle = stroke;
      ctx.lineWidth   = 1;
      // 开始新路径并绘制圆角矩形
      ctx.beginPath();
      ctx.roundRect(x + i * offset, y + i * offset, w, h, 5);
      ctx.fill();
      ctx.stroke();
      // 恢复到 save() 时的状态（包括 globalAlpha）
      ctx.restore();
    }
  }

  /**
   * 在 canvas 上绘制一个正方形网格并居中填入二维数组，可高亮部分格子
   * @param {number[][]} data 二维数组
   * @param {number} gridX 左上角 x 坐标
   * @param {number} gridY 左上角 y 坐标
   * @param {number} cellSize 每个格子边长
   * @param {Array<[number, number]>} highlightCells 高亮格子的坐标列表（如 [[0,1], [2,2]]）
   * @param {string} color 高亮颜色, 默认为 'rgba(255, 255, 0, 0.4)'
   */
  function drawCenteredGridWithData(ctx, data, gridX, gridY, cellSize, highlightCells = [], color = 'rgba(255, 255, 0, 0.4)') {
    const rows = data.length;
    const cols = data[0].length;
    const totalSize = Math.max(rows, cols) * cellSize;

    const offsetX = (totalSize - cols * cellSize) / 2;
    const offsetY = (totalSize - rows * cellSize) / 2;

    ctx.font = `${cellSize * 0.4}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < cols; j++) {
        const x = gridX + offsetX + j * cellSize;
        const y = gridY + offsetY + i * cellSize;

        // 检查是否为高亮格子
        const isHighlighted = highlightCells.some(([hi, hj]) => hi === i && hj === j);
        if (isHighlighted) {
          ctx.fillStyle = color;
          ctx.fillRect(x, y, cellSize, cellSize);
        }

        // 绘制边框和文字
        ctx.strokeStyle = isHighlighted ? '#ff9900' : '#000'; // 高亮边框为橙色
        ctx.strokeRect(x, y, cellSize, cellSize);
        ctx.fillStyle = '#000';
        ctx.fillText(data[i][j], x + cellSize / 2, y + cellSize / 2);
      }
    }
  }

  /**
   * 绘制带箭头的连接线，并在终点右侧添加文字
   * @param {CanvasRenderingContext2D} ctx canvas 上下文
   * @param {number} fromX 起点 x 坐标
   * @param {number} fromY 起点 y 坐标
   * @param {number} toX   终点 x 坐标
   * @param {number} toY   终点 y 坐标
   * @param {string} color 线条颜色
   * @param {number} width 线宽
   * @param {boolean} dashed 是否为虚线
   * @param {string} label 文字内容（可选）
   * @param {string} font 字体设置（默认 '12px sans-serif'）
   * @param {string} labelposition
   */
  function drawConnectorWithArrow(ctx, fromX, fromY, toX, toY, color = '#333', width = 2, dashed = false, label = '', font = '12px sans-serif', labelposition = "right") {
    const headlen = 10; // 箭头长度
    const angle = Math.atan2(toY - fromY, toX - fromX);

    ctx.save();
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = width;
    if (dashed) ctx.setLineDash([5, 5]);

    // 主线
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();

    // 箭头
    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(
      toX - headlen * Math.cos(angle - Math.PI / 6),
      toY - headlen * Math.sin(angle - Math.PI / 6)
    );
    ctx.lineTo(
      toX - headlen * Math.cos(angle + Math.PI / 6),
      toY - headlen * Math.sin(angle + Math.PI / 6)
    );
    ctx.lineTo(toX, toY);
    ctx.closePath();
    ctx.fill();

    // 清除虚线设置
    if (dashed) ctx.setLineDash([]);

    // 添加文字（在终点右侧偏移位置）
    // 添加文字（根据 labelPosition 定位）
    if (label) {
      const offset = 8;
      ctx.font = font;
      ctx.fillStyle = color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      if (labelPosition === 'right') {
        ctx.textAlign = 'center';
        let labelX = toX + offset;
        let labelY = toY;
        if (fromY < toY) {
          labelY -= offset;
        } else if (fromY > toY) {
          labelY += offset;
        } else {
          labelY = fromY;
        }
        ctx.fillText(label, labelX, labelY);
      } else if (labelPosition === 'top') {
        ctx.textAlign = 'center';
        let labelX = (fromX + toX) / 2;
        let labelY = fromY;
        if (fromY < toY) {
          labelY += offset;
        } else if (fromY > toY) {
          labelY -= offset;
        } else {
          labelY = fromY;
        }
        ctx.fillText(label, labelX, labelY);
      } else if (labelPosition === 'bottom') {
        ctx.textAlign = 'center';
        let labelX = (fromX + toX) / 2;
        let labelY = fromY;
        if (fromY < toY) {
          labelY -= offset;
        } else if (fromY > toY) {
          labelY += offset;
        } else {
          labelY = fromY;
        }
        ctx.fillText(label, labelX, labelY);
      }

    }

    ctx.restore();
  }

  // 绘制一系列纵向排列的圆圈
  /**
   * 垂直绘制一组圆圈
   * @param {CanvasRenderingContext2D} ctx  Canvas 上下文
   * @param {number} startX      起始 x 坐标
   * @param {number} startY      起始 y 坐标
   * @param {number} radius      圆半径
   * @param {number} count       圆的个数
   * @param {number} spacing     圆心之间的垂直间距
   * @param {string} fillColor   填充色
   * @param {string} strokeColor 边框色
   */
  function drawVerticalCircles(ctx, startX, startY, radius, count, spacing, fillColor = '#88c', strokeColor = '#333') {
    ctx.save();
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 1;

    for (let i = 0; i < count; i++) {
      const y = startY + i * spacing;
      ctx.beginPath();
      ctx.arc(startX, y, radius, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
    }

    ctx.restore();
  }

  /**
   * 将两组点之间按全连接方式绘制线条
   * @param {CanvasRenderingContext2D} ctx canvas 上下文
   * @param {[number, number][]} fromPoints 起点坐标组（如 [[x1,y1], [x2,y2], ...]）
   * @param {[number, number][]} toPoints   终点坐标组（如 [[x1,y1], [x2,y2], ...]）
   * @param {function} connectorFn 使用的连接函数（如 drawConnector）
   */
  function drawFullConnection(ctx, fromPoints, toPoints, connectorFn) {
    for (const [fx, fy] of fromPoints) {
      for (const [tx, ty] of toPoints) {
        connectorFn(ctx, fx, fy, tx, ty);
      }
    }
  }

  /**
   * 绘制一个带圆角矩形，并在其中心添加文字，在左侧显示编号
   * @param {CanvasRenderingContext2D} ctx     canvas 上下文
   * @param {number} x                         左上角 x 坐标
   * @param {number} y                         左上角 y 坐标
   * @param {number} width                     矩形宽度
   * @param {number} height                    矩形高度
   * @param {string} text                      中心显示文字
   * @param {string|number} number             左侧编号文本（如“1”）
   * @param {string} fillColor                 矩形填充色
   * @param {string} strokeColor               矩形边框色
   * @param {number} radius                    圆角半径（默认 10）
   * @param {string} font                      主文字字体（默认 '14px sans-serif'）
   * @param {string} numberFont                编号字体（默认 '12px sans-serif'）
   * @param {string} numberBgColor             编号背景色（默认 '#fff'）
   */
  function drawLabeledRoundedRectWithNumber(ctx, x, y, width, height, text, number, fillColor = '#eef', strokeColor = '#333', radius = 10, font = '14px sans-serif', numberFont = '12px sans-serif', numberBgColor = '#fff') {
    ctx.save();
    // 编号圆参数
    const circleRadius = 12;
    const circleCenterX = x - circleRadius - 6;
    const circleCenterY = y + height / 2;
    // 绘制左侧编号圆圈
    if (number) {
      ctx.beginPath();
      ctx.arc(circleCenterX, circleCenterY, circleRadius, 0, 2 * Math.PI);
      ctx.fillStyle = numberBgColor;
      ctx.fill();
      ctx.strokeStyle = strokeColor;
      ctx.stroke();
      // 编号文字
      ctx.font = numberFont;
      ctx.fillStyle = '#000';
      ctx.textAlign = 'center';
    }
    ctx.textBaseline = 'middle';
    ctx.fillText(number, circleCenterX, circleCenterY);
    // 绘制圆角矩形
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    // 填充和描边
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.strokeStyle = strokeColor;
    ctx.stroke();
    // 主体文字
    ctx.font = font;
    ctx.fillStyle = '#000';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x + width / 2, y + height / 2);
    ctx.restore();
  }

</script>
<script> // 第一个画布
  const canvas = document.getElementById('cnnCanvas');
  const ctx1 = canvas.getContext('2d');

  // 输入层
  const inputMap = { x: 20, y: 90, w: 50, h: 50, count: 3, off: 10 };
  drawLayer(ctx1, inputMap.x, inputMap.y, inputMap.w, inputMap.h, inputMap.count, inputMap.off, fm1Color, convStroke, 3);
  ctx1.fillStyle = '#222'; ctx1.font = '14px sans-serif';
  ctx1.fillText('输入层', inputMap.x, inputMap.y - 10);

  // 输入层选中区域
  const selInput = { x: inputMap.x + 4 * inputMap.off, y: inputMap.y + 4 * inputMap.off, w: 12, h: 12 };
  ctx1.strokeStyle = dashColor2; ctx1.setLineDash([3, 3]);
  ctx1.strokeRect(selInput.x, selInput.y, selInput.w, selInput.h);
  ctx1.setLineDash([]);

  // 特征图 1
  const fm1 = { x: 120, y: 50, w: 100, h: 100, count: 5, off: 10 };
  drawLayer(ctx1, fm1.x, fm1.y, fm1.w, fm1.h, fm1.count, fm1.off, fm1Color, convStroke, 3);
  ctx1.fillStyle = '#222'; ctx1.font = '14px sans-serif';
  ctx1.fillText('特征图 1', fm1.x, fm1.y - 10);

  // 输入层到特征图1的连线
  const fromX1Input = selInput.x + selInput.w;
  const fromY1Input = selInput.y;
  const fromX2Input = selInput.x + selInput.w;
  const fromY2Input = selInput.y + selInput.h;
  drawConnector(ctx1, fromX1Input, fromY1Input, fm1.x + 9 * fm1.off, fm1.y + 9 * fm1.off);
  drawConnector(ctx1, fromX2Input, fromY2Input, fm1.x + 9 * fm1.off, fm1.y + 9 * fm1.off);
  // 在连线下方添加文字
  ctx1.fillStyle = '#222'; ctx1.font = '14px sans-serif';
  ctx1.fillText('卷积', (fromX1Input + fm1.x + 1 * fm1.off) / 2 - 10, (fromY1Input + fm1.y) - 10);

  // 特征图 1 选中区域（虚线框）
  const sel1 = { x: fm1.x + 7 * fm1.off, y: fm1.y + 7 * fm1.off, w: 25, h: 25};
  ctx1.strokeStyle = dashColor2; ctx1.setLineDash([3, 3]);
  ctx1.strokeRect(sel1.x, sel1.y, sel1.w, sel1.h);
  ctx1.setLineDash([]);

  // 特征图 2
  const fm2 = { x: 290, y: 70, w: 60, h: 60, count: 5, off: 8 };
  drawLayer(ctx1, fm2.x, fm2.y, fm2.w, fm2.h, fm2.count, fm2.off, fm2Color, poolStroke, 3);
  ctx1.fillStyle = '#222'; ctx1.font = '14px sans-serif';
  ctx1.fillText('特征图 2', fm2.x, fm2.y - 10);

  // 特征图 2 选中区域
  const sel2 = { x: fm2.x + 7 * fm2.off, y: fm2.y + 5 * fm2.off, w: 15, h: 15 };
  ctx1.strokeStyle = dashColor2; ctx1.setLineDash([3, 3]);
  ctx1.strokeRect(sel2.x, sel2.y, sel2.w, sel2.h);
  ctx1.setLineDash([]);

  // 从特征图1选中到特征图2的连线,双线汇于一点，起点为右上角和右下角
  const fromX1Sel1 = sel1.x + sel1.w;
  const fromY1Sel1 = sel1.y;
  const fromX2Sel1 = sel1.x + sel1.w;
  const fromY2Sel1 = sel1.y + sel1.h;
  const toX = fm2.x + 8 * fm2.off;
  const toY = fm2.y + 6 * fm2.off;
  drawConnector(ctx1, fromX1Sel1, fromY1Sel1, toX, toY);
  drawConnector(ctx1, fromX2Sel1, fromY2Sel1, toX, toY);
  // 在连线下方添加文字
  ctx1.fillStyle = '#222'; ctx1.font = '14px sans-serif';
  ctx1.fillText('池化', (fromX1Sel1 + fm2.x + 3 * fm2.off) / 2, (fromY1Sel1 + fm2.y) - 30);

  // 特征图 3
  const fm3 = { x: 390, y: 50, w: 70, h: 70, count: 12, off: 8 };
  drawLayer(ctx1, fm3.x, fm3.y, fm3.w, fm3.h, fm3.count, fm3.off, fm1Color, convStroke, 9);
  ctx1.fillStyle = '#222'; ctx1.font = '14px sans-serif';
  ctx1.fillText('特征图 3', fm3.x, fm3.y - 10);

  // 特征图 3 选中区域
  const sel3 = { x: fm3.x + 15 * fm3.off, y: fm3.y + 14 * fm3.off, w: 15, h: 15 };
  ctx1.strokeStyle = dashColor2; ctx1.setLineDash([3, 3]);
  ctx1.strokeRect(sel3.x, sel3.y, sel3.w, sel3.h);
  ctx1.setLineDash([]);

  // 从特征图2选中到特征图3的连线,双线汇于一点，起点为右上角和右下角
  const fromX1Sel2 = sel2.x + sel2.w;
  const fromY1Sel2 = sel2.y;
  const fromX2Sel2 = sel2.x + sel2.w;
  const fromY2Sel2 = sel2.y + sel2.h;
  drawConnector(ctx1, fromX1Sel2, fromY1Sel2, fm3.x + 16 * fm3.off, fm3.y + 15 * fm3.off);
  drawConnector(ctx1, fromX2Sel2, fromY2Sel2, fm3.x + 16 * fm3.off, fm3.y + 15 * fm3.off);
  // 在连线下方添加文字
  ctx1.fillStyle = '#222'; ctx1.font = '14px sans-serif';
  ctx1.fillText('卷积', (fromX1Sel2 + fm3.x + 4 * fm3.off) / 2, (fromY1Sel2 + fm3.y));

  // 特征图 4
  const fm4 = { x: 525, y: 70, w: 40, h: 40, count: 12, off: 8 };
  drawLayer(ctx1, fm4.x, fm4.y, fm4.w, fm4.h, fm4.count, fm4.off, fm2Color, poolStroke, 9);
  ctx1.fillStyle = '#222'; ctx1.font = '14px sans-serif';
  ctx1.fillText('特征图 4', fm4.x, fm4.y - 10);

  // 特征图3选中区域到特征图4选中区域的连线
  const fromX1Sel3 = sel3.x + sel3.w;
  const fromY1Sel3 = sel3.y;
  const fromX2Sel3 = sel3.x + sel3.w;
  const fromY2Sel3 = sel3.y + sel3.h;
  const toX2 = fm4.x + 13 * fm4.off;
  const toY2 = fm4.y + 13 * fm4.off;
  drawConnector(ctx1, fromX1Sel3, fromY1Sel3, toX2, toY2);
  drawConnector(ctx1, fromX2Sel3, fromY2Sel3, toX2, toY2);
  // 在连线下方添加文字
  ctx1.fillStyle = '#222'; ctx1.font = '14px sans-serif';
  ctx1.fillText('池化', (fromX1Sel3 + fm4.x + 7 * fm4.off) / 2, (fromY1Sel3 + fm4.y) - 35);

  // 全连接层
  const fc = { x: 620, y: 90, count: 10, space: 10, r: 8 };
  ctx1.fillStyle = '#222'; ctx1.font = '14px sans-serif';
  ctx1.fillText('全连接层', fc.x, fc.y - 20);
  for (let i = 0; i < fc.count; i++) {
    ctx1.beginPath();
    ctx1.fillStyle = 'rgba(128,222,233,0.8)';
    ctx1.strokeStyle = 'purple';
    ctx1.lineWidth = 1;
    ctx1.arc(fc.x + i * fc.space, fc.y + i * fc.space, fc.r, 0, 2 * Math.PI);
    ctx1.fill(); ctx1.stroke();
  }

  // 特征图 3 到全连接层的连线
  const fromX1Fm4 = fm4.x + fm4.w;
  const fromY1Fm4 = fm4.y;
  const fromX2Fm4 = fm4.x + fm4.w + (fm4.count - 1) * fm4.off;
  const fromY2Fm4 = fm4.y + fm4.h + (fm4.count - 1) * fm4.off;
  drawConnector(ctx1, fromX1Fm4, fromY1Fm4, fc.x, fc.y);
  drawConnector(ctx1, fromX2Fm4, fromY2Fm4, fc.x + (fc.count - 1) * fc.space, fc.y + (fc.count - 1) * fc.space);

  // 输出层
  const outX = fc.x + (fc.count - 1) * fc.space + 10;
  const outY = fc.y + (fc.count / 2) * fc.space;
  ctx1.fillStyle = '#222'; ctx1.font = '14px sans-serif';
  ctx1.fillText('输出层', outX, outY - 20);
  ctx1.beginPath();
  // 浅蓝色
  ctx1.fillStyle = 'rgba(128,222,233,0.8)'; ctx1.strokeStyle = 'purple';
  ctx1.arc(outX + 20, outY, fc.r, 0, 2 * Math.PI);
  ctx1.fill(); ctx1.stroke();

  // 连接到输出层
  const fromX1Fc = fc.x;
  const fromY1Fc = fc.y;
  const fromX2Fc = fc.x + (fc.count - 1) * fc.space;
  const fromY2Fc = fc.y + (fc.count - 1) * fc.space;
  drawConnector(ctx1, fromX1Fc, fromY1Fc, outX + 20, outY);
  drawConnector(ctx1, fromX2Fc, fromY2Fc, outX + 20, outY);

  // 创建按钮保存以上绘制的图像
  const saveBtn = document.createElement('button');
  saveBtn.innerText = '保存图像1';
  saveBtn.style.position = 'absolute';
  saveBtn.style.top = '10px';
  saveBtn.style.right = '10px';
  saveBtn.onclick = function() {
    const link = document.createElement('a');
    link.download = 'cnn_structure.png';
    link.href = canvas.toDataURL();
    link.click();
  };
  document.body.appendChild(saveBtn);
</script>
<script> // 第二个画布
  const canvas2 = document.getElementById('cnnCanvas2');
  const ctx2 = canvas2.getContext('2d');

  // 绘制第一列圆圈 6
  // 半透明紫色
  drawVerticalCircles(ctx2, 50, 32, 12, 6, 35, "rgba(128,222,233,0.8)");
  // 根据第一列圆圈生成一组每个圆圈右边的坐标点
  pos1 = [];
  for (let i = 0; i < 6; i++) {
    pos1.push([65, 32 + i * 35]);
  }
  // 绘制第二列圆圈 4
  // 半透明绿色
  drawVerticalCircles(ctx2, 150, 32 + 35, 12, 4, 35, "rgba(144,238,144,0.8)");
  // 根据第二列圆圈生成一组每个圆圈左边的坐标点
  pos2 = [];
  for (let i = 0; i < 4; i++) {
    pos2.push([150 - 12, 32 + 35 + i * 35]);
  }
  // 调用函数绘制全连接
  drawFullConnection(ctx2, pos1, pos2, drawConnector);
  // 创建第三列圆圈 2
  drawVerticalCircles(ctx2, 250, 32 + 35 * 2, 12, 2, 35);
  pos3 = []
  for (let i = 0; i < 4; i++) {
    pos3.push([150 + 12, 32 + 35 + i * 35]);
  }
  pos4 = []
  for (let i = 0; i < 2; i++) {
    pos4.push([250 - 12, 32 + 35 * 2 + i * 35]);
  }
  drawFullConnection(ctx2, pos3, pos4, drawConnector);
  // 创建按钮保存画布2
  const saveBtn2 = document.createElement('button');
  saveBtn2.innerText = '保存图像2';
  saveBtn2.style.position = 'absolute';
  saveBtn2.style.top = '40px';
  saveBtn2.style.right = '10px';
  document.body.appendChild(saveBtn2);
  saveBtn2.onclick = function() {
      const link = document.createElement('a');
      link.download = 'cnn_structure2.png';
      link.href = canvas2.toDataURL();
      link.click();
    };
</script>
<script> // 第三个画布
  const canvas3 = document.getElementById('cnnCanvas3');
  const ctx3 = canvas3.getContext('2d');

  // 原始图像数据
  const data = [
    [1, 2, 3, 0, 1],
    [0, 1, 2, 3, 1],
    [1, 0, 1, 2, 2],
    [2, 1, 0, 1, 0],
    [1, 3, 1, 0, 2]
  ];

  // 高亮第一感受野区域（左上角 3x3）
  const highlightCells = [
    [0, 0], [0, 1], [0, 2],
    [1, 0], [1, 1], [1, 2],
    [2, 0], [2, 1], [2, 2]
  ];

// 原图网格
const gridX = 20, gridY = 60, cellSize = 30;
drawCenteredGridWithData(ctx3, data, gridX, gridY, cellSize, highlightCells);

// 标题
ctx3.fillStyle = '#222'; ctx3.font = '14px sans-serif';
ctx3.fillText('Input Image (5x5)', gridX + cellSize * 2.5, gridY - 10);

// 全1卷积核
const kernel = [
  [1, 1, 1],
  [1, 1, 1],
  [1, 1, 1]
];

// 绘制图像
drawCenteredGridWithData(ctx3, kernel, 240, 90, 30);
ctx3.fillStyle = '#222'; ctx3.font = '14px sans-serif';
ctx3.fillText('Convolution Kernel (3x3)', 240 + 45, 60);

// 绘制高亮区域四个角点到卷积核四个角点的连线
// 起点在原图像上的坐标
const kernelCorners = [
  [0, 0], [0, 3],
  [3, 0], [3, 3]
];
// 终点在卷积核上的坐标
const kernelCornersInKernel = [
  [0, 0], [0, 3],
  [3, 0], [3, 3]
];
// 根据坐标生成起点和终点的实际像素坐标
const kernelHighlightCells = [];
for (let i = 0; i < kernelCorners.length; i++) {
  const [x1, y1] = kernelCorners[i];
  const [x2, y2] = kernelCornersInKernel[i];
  const startX = gridX + x1 * cellSize;
  const startY = gridY + y1 * cellSize;
  const endX = 240 + x2 * cellSize;
  const endY = 90 + y2 * cellSize;
  kernelHighlightCells.push([startX, startY, endX, endY]);
}
// 绘制连线
for (let i = 0; i < kernelHighlightCells.length; i++) {
  const [x1, y1, x2, y2] = kernelHighlightCells[i];
  ctx3.strokeStyle = '#ff9900'; // 橙色
  ctx3.setLineDash([5, 5]);
  ctx3.beginPath();
  ctx3.moveTo(x1, y1);
  ctx3.lineTo(x2, y2);
  ctx3.stroke();
}

for (let i = 0; i < kernelHighlightCells.length; i++) {
  const [x1, y1, x2, y2] = kernelHighlightCells[i];
  ctx3.strokeStyle = '#ff9900'; // 橙色
  ctx3.setLineDash([5, 5]);
  ctx3.beginPath();
  ctx3.moveTo(x1, y1);
  ctx3.lineTo(x2, y2);
  ctx3.stroke();
}
ctx3.setLineDash([]);

// 输出图像：3x3（假设卷积核为全 1，仅作演示）
const output = [
  [12, 14, 13],
  [9,  9,  9],
  [11, 8,  9]
];

drawCenteredGridWithData(ctx3, output, 440, 90, 30);
ctx3.fillStyle = '#222'; ctx3.font = '14px sans-serif';
ctx3.fillText('Output Feature Map (3x3)', 440 + 45, 60);

  // 绘制箭头
const arrowStartX = 240 + 4 * cellSize;
const arrowStartY = 90 + 1.5 * cellSize;
const arrowEndX = 440 - cellSize;
const arrowEndY = 90 + 1.5 * cellSize;

drawConnectorWithArrow(ctx3, arrowStartX, arrowStartY, arrowEndX, arrowEndY);
// 创建一个保存画布3的按钮
const saveBtn3 = document.createElement('button');
saveBtn3.innerText = '保存图像3';
saveBtn3.style.position = 'absolute';
saveBtn3.style.top = '70px';
saveBtn3.style.right = '10px';
document.body.appendChild(saveBtn3);
saveBtn3.onclick = function() {
    const link = document.createElement('a');
    link.download = 'cnn_structure3.png';
    link.href = canvas3.toDataURL();
    link.click();
  };
</script>
<script> // 第四个画布
  const canvas4 = document.getElementById('cnnCanvas4');
  const ctx4 = canvas4.getContext('2d');

  // 4x4的输入图像网格
  const input4x4 = [
    [1, 2, 3, 0],
    [0, 1, 2, 3],
    [1, 0, 1, 2],
    [2, 1, 0, 1]
  ];

  // 池化输入图像分四组高亮区域,每个区域一种颜色
  const highlightCellsOnPooling = [
    [[0, 0], [0, 1], [1, 0], [1, 1]],  // 第一组
    [[0, 2], [0, 3], [1, 2], [1, 3]],  // 第二组
    [[2, 0], [2, 1], [3, 0], [3, 1]],  // 第三组
    [[2, 2], [2, 3], [3, 2], [3, 3]]   // 第四组
  ];
  // 四种颜色
  const highlightColors = [
    'rgba(255, 0, 0, 0.4)',   // 红色
    'rgba(0, 255, 0, 0.4)',   // 绿色
    'rgba(255, 255, 0, 0.4)',  // 黄色
    'rgba(0, 0, 255, 0.4)',   // 蓝色
  ];
  // drawCenteredGridWithData(ctx4, input4x4, 20, 60, 30);
  // 根据四组高亮分四步完成网格的绘制,每次绘制一个2x2的网格
  for (let i = 0; i < highlightCellsOnPooling.length; i++) {
    const group = highlightCellsOnPooling[i];
    const color = highlightColors[i];
    drawCenteredGridWithData(ctx4, input4x4, gridX, gridY, cellSize, group, color);
  }
  ctx4.fillStyle = '#222'; ctx4.font = '14px sans-serif';
  ctx4.fillText('Input Image (4x4)', 20 + 30 * 2, 60 - 10);

  // 计算 2x2 池化结果（步长=2）
  function maxPool2x2(input) {
    const out = [];
    for (let i = 0; i < 4; i += 2) {
      const row = [];
      for (let j = 0; j < 4; j += 2) {
        row.push(Math.max(
          input[i][j], input[i][j + 1],
          input[i + 1][j], input[i + 1][j + 1]
        ));
      }
      out.push(row);
    }
    return out;
  }

  function avgPool2x2(input) {
    const out = [];
    for (let i = 0; i < 4; i += 2) {
      const row = [];
      for (let j = 0; j < 4; j += 2) {
        const sum = input[i][j] + input[i][j + 1] + input[i + 1][j] + input[i + 1][j + 1];
        row.push((sum / 4).toFixed(1)); // 保留一位小数
      }
      out.push(row);
    }
    return out;
  }

  // 获取池化结果
  const maxPooled = maxPool2x2(input4x4);
  const avgPooled = avgPool2x2(input4x4);

  // 绘制最大池化结果
  drawCenteredGridWithData(ctx4, maxPooled, 240, 40, 30);
  ctx4.fillStyle = '#222'; ctx4.font = '14px sans-serif';
  ctx4.fillText('Max Pooling (2x2)', 240 + 30, 30);

  // 绘制平均池化结果
  drawCenteredGridWithData(ctx4, avgPooled, 240, 140, 30);
  ctx4.fillStyle = '#222'; ctx4.font = '14px sans-serif';
  ctx4.fillText('Avg Pooling (2x2)', 240 + 30, 130);

  // 连线：输入 → 最大池化
  drawConnectorWithArrow(ctx4, 20 + 30 * 4.5, 40 + 30 * 1, 240 - 30 * 0.5, 40 + 30, '#0060ff', 2, false);
  // 连线：输入 → 平均池化
  drawConnectorWithArrow(ctx4, 20 + 30 * 4.5, 140 + 30 * 1, 240 - 30 * 0.5, 140 + 30 * 1, '#00aa00', 2, false);
  // 创建一个保存画布4的按钮
  const saveBtn4 = document.createElement('button');
  saveBtn4.innerText = '保存图像4';
  saveBtn4.style.position = 'absolute';
  saveBtn4.style.top = '100px';
  saveBtn4.style.right = '10px';
  document.body.appendChild(saveBtn4);
  saveBtn4.onclick = function() {
      const link = document.createElement('a');
      link.download = 'cnn_structure4.png';
      link.href = canvas4.toDataURL();
      link.click();
    };
</script>
<script> // 第五个画布
  const canvas5 = document.getElementById('cnnCanvas5');
  const ctx5 = canvas5.getContext('2d');
  drawConnectorWithArrow(ctx5, 40 + 30, 215 + 30, 40 + 30, 215, "rgba(0,0,0,1)", 2, false, "640x640x3", "12px sans-serif", labelPosition="right");

  drawLabeledRoundedRectWithNumber(ctx5, 40, 215 - 30, 60, 30, "Conv", "0", "rgba(133, 237, 255, 0.4)", radius=4);
  drawConnectorWithArrow(ctx5, 40 + 30, 215 - 30, 40 + 30, 215 - 30 * 2, "rgba(0,0,0,1)", 2, false, "320x320x64", "12px sans-serif", labelPosition="right");
  
  drawLabeledRoundedRectWithNumber(ctx5, 40, 215 - 30 * 3, 60, 30, "Conv", 1, "rgba(133, 237, 255, 0.4)", radius=4);
  drawConnectorWithArrow(ctx5, 40 + 30, 215 - 30 * 3, 40 + 30, 215 - 30 * 4, "rgba(0,0,0,1)", 2, false, "160x160x128", "12px sans-serif", labelPosition="right");

  drawLabeledRoundedRectWithNumber(ctx5, 40, 215 - 30 * 5, 60, 30, "C2f", 2, "rgba(199, 255, 231, 0.4)", radius=4);
  drawConnectorWithArrow(ctx5, 40 + 30, 215 - 30 * 5, 40 + 30, 215 - 30 * 6, "rgba(0,0,0,1)", 2, false, "160x160x128", "12px sans-serif", labelPosition="right");

  drawLabeledRoundedRectWithNumber(ctx5, 40, 215 - 30 * 7, 60, 30, "Conv", 3, "rgba(133, 237, 255, 0.4)", radius=4);
  drawConnectorWithArrow(ctx5, 40 + 60, 215 - 30 * 7 + 30 / 2, 40 + 60 + 60 + 60, 215 - 30 * 7 + 30 / 2, "rgba(0,0,0,1)", 2, false, "80x80x256", "12px sans-serif", labelPosition="top");

  drawLabeledRoundedRectWithNumber(ctx5, 255, 215 - 30 * 7, 60, 30, "C2f", 4, "rgba(199, 255, 231, 0.4)", radius=4);
  drawConnectorWithArrow(ctx5, 255 + 30, 215 - 30 * 6, 255 + 30, 215 - 30 * 5, "rgba(0,0,0,1)", 2, false, "80x80x256", "12px sans-serif", labelPosition="right");
  drawConnectorWithArrow(ctx5, 255 + 60, 215 - 30 * 7 + 30 / 2, 255 + 60 + 60 + 40, 215 - 30 * 7 + 30 / 2, "rgba(0,0,0,1)", 2, false, "P3 80x80x256", "12px sans-serif", labelPosition="top");

  drawLabeledRoundedRectWithNumber(ctx5, 255, 215 - 30 * 5, 60, 30, "Conv", 5, "rgba(133, 237, 255, 0.4)", radius=4);
  drawConnectorWithArrow(ctx5, 255 + 30, 215 - 30 * 4, 255 + 30, 215 - 30 * 3, "rgba(0,0,0,1)", 2, false, "40x40x512", "12px sans-serif", labelPosition="right");

  drawLabeledRoundedRectWithNumber(ctx5, 255, 215 - 30 * 3, 60, 30, "C2f", 6, "rgba(199, 255, 231, 0.4)", radius=4);
  drawConnectorWithArrow(ctx5, 255 + 30, 215 - 30 * 2, 255 + 30, 215 - 30 * 1, "rgba(0,0,0,1)", 2, false, "40x40x512", "12px sans-serif", labelPosition="right");
  drawConnectorWithArrow(ctx5, 255 + 60, 215 - 30 * 3 + 30 / 2, 255 + 60 + 60 + 40, 215 - 30 * 3 + 30 / 2, "rgba(0,0,0,1)", 2, false, "P4 40x40x512", "12px sans-serif", labelPosition="top");

  drawLabeledRoundedRectWithNumber(ctx5, 255, 215 - 30 * 1, 60, 30, "Conv", 7, "rgba(133, 237, 255, 0.4)", radius=4);
  drawConnectorWithArrow(ctx5, 255 + 60, 215 - 30 * 1 + 30 / 2, 255 + 60 + 60 + 60, 215 - 30 * 1 + 30 / 2, "rgba(0,0,0,1)", 2, false, "20x20x1024", "12px sans-serif", labelPosition="top");

  drawLabeledRoundedRectWithNumber(ctx5, 470, 215 - 30 * 1, 60, 30, "C2f", 8, "rgba(199, 255, 231, 0.4)", radius=4);
  drawConnectorWithArrow(ctx5, 470 + 30, 215 - 30 * 1, 470 + 30, 215 - 30 * 4, "rgba(0,0,0,1)", 2, false, "20x20x1024", "12px sans-serif", labelPosition="right");
  
  drawLabeledRoundedRectWithNumber(ctx5, 470, 215 - 30 * 5, 60, 30, "SPPF", 9, "rgba(255, 173, 213, 0.7)", radius=4);
  drawConnectorWithArrow(ctx5, 470 + 60, 215 - 30 * 5 + 30 / 2, 470 + 60 + 60 + 40, 215 - 30 * 5 + 30 / 2, "rgba(0,0,0,1)", 2, false, "P5 20x20x1024", "12px sans-serif", labelPosition="top");

  // 创建一个按钮保存画布5
  const saveBtn5 = document.createElement('button');
  saveBtn5.innerText = '保存图像5';
  saveBtn5.style.position = 'absolute';
  saveBtn5.style.top = '130px';
  saveBtn5.style.right = '10px';
  document.body.appendChild(saveBtn5);
  saveBtn5.onclick = function() {
      const link = document.createElement('a');
      link.download = 'cnn_structure5.png';
      link.href = canvas5.toDataURL();
      link.click();
    };
</script>
<script> // 第六个画布 ConvModule内部
  const canvas6 = document.getElementById('cnnCanvas6');
  const ctx6 = canvas6.getContext('2d');

  // Conv2d
  drawConnectorWithArrow(ctx6, 100, 5, 100, 210 - 60 * 3, "rgba(0,0,0,1)", 2, false, "", "12px sans-serif", "right");
  drawLabeledRoundedRectWithNumber(ctx6, 100 - 50, 210 - 60 * 3, 100, 60, "Conv2d", "", "rgba(133, 237, 255, 0.4)", 4);

  // BatchNorm2d
  drawConnectorWithArrow(ctx6, 100, 210 - 60 * 3 + 60, 100, 210 - 30 * 3, "rgba(0,0,0,1)", 2, false, "", "12px sans-serif", "right");
  drawLabeledRoundedRectWithNumber(ctx6, 80 - 40, 210 - 30 * 3, 120, 40, "BatchNorm2d", "", "rgba(199, 255, 231, 0.4)", 4);

  // SiLU
  drawConnectorWithArrow(ctx6, 100, 210 - 30 * 2 + 10, 100, 210 - 30 * 1 + 10, "rgba(0,0,0,1)", 2, false, "", "12px sans-serif", "right");
  drawLabeledRoundedRectWithNumber(ctx6, 90 - 30, 210 - 30 * 1 + 10, 80, 30, "SiLU", "", "rgba(255, 239, 199, 0.6)", 4);

  drawConnectorWithArrow(ctx6, 100, 210 + 10, 100, 210 + 35, "rgba(0,0,0,1)", 2, false, "", "12px sans-serif", "right");

  drawLabeledRoundedRectWithNumber(ctx6, 20, 15, 160, 215, "", "", "rgba(255,255,255,0)", 4);

  // 创建一个按钮保存画布6
  const saveBtn6 = document.createElement('button');
  saveBtn6.innerText = '保存图像6';
  saveBtn6.style.position = 'absolute';
  saveBtn6.style.top = '160px';
  saveBtn6.style.right = '10px';
  document.body.appendChild(saveBtn6);
  saveBtn6.onclick = function() {
      const link = document.createElement('a');
      link.download = 'cnn_structure6.png';
      link.href = canvas6.toDataURL();
      link.click();
    };
</script>
<script>
// 第7个画布：绘制 YOLOv8 的 CSPLayer_2Conv 模块结构
const canvas7 = document.getElementById('cnnCanvas7');
const ctx7 = canvas7.getContext('2d');

// 基础坐标
const centerX = 200;
const startY = 40;
const boxWidth = 100;
const boxHeight = 40;
const spacingY = 50;
const spacingX = 80;

// 输入 → 分支 Conv1 和 Conv2
drawLabeledRoundedRectWithNumber(ctx7, centerX - 50, startY, boxWidth, boxHeight, 'Input', '', '#eee', '#999', 6);
drawConnectorWithArrow(ctx7, centerX, startY + boxHeight, centerX - spacingX, startY + spacingY, '#000', 2, false);
drawConnectorWithArrow(ctx7, centerX, startY + boxHeight, centerX + spacingX, startY + spacingY, '#000', 2, false);

// Conv1 分支
drawLabeledRoundedRectWithNumber(ctx7, centerX - spacingX - boxWidth / 2, startY + spacingY, boxWidth, boxHeight, 'Conv1', '', 'rgba(133, 237, 255, 0.4)', '#0060aa', 6);

// Conv2 分支
drawLabeledRoundedRectWithNumber(ctx7, centerX + spacingX - boxWidth / 2, startY + spacingY, boxWidth, boxHeight, 'Conv2', '', 'rgba(133, 237, 255, 0.4)', '#0060aa', 6);

// 两分支向下合并
drawConnectorWithArrow(ctx7, centerX - spacingX, startY + spacingY + boxHeight, centerX, startY + spacingY * 2, '#000', 2, false);
drawConnectorWithArrow(ctx7, centerX + spacingX, startY + spacingY + boxHeight, centerX, startY + spacingY * 2, '#000', 2, false);

// Concat
drawLabeledRoundedRectWithNumber(ctx7, centerX - boxWidth / 2, startY + spacingY * 2, boxWidth, boxHeight, 'Concat', '', '#ffe', '#666', 6);

// Concat → Conv3
drawConnectorWithArrow(ctx7, centerX, startY + spacingY * 2 + boxHeight, centerX, startY + spacingY * 3, '#000', 2, false);

// Conv3（融合）
drawLabeledRoundedRectWithNumber(ctx7, centerX - boxWidth / 2, startY + spacingY * 3, boxWidth, boxHeight, 'Conv3', '', 'rgba(199, 255, 231, 0.4)', '#008800', 6);

// 输出
drawConnectorWithArrow(ctx7, centerX, startY + spacingY * 3 + boxHeight, centerX, startY + spacingY * 4, '#000', 2, false);
drawLabeledRoundedRectWithNumber(ctx7, centerX - boxWidth / 2, startY + spacingY * 4, boxWidth, boxHeight, 'Output', '', '#eee', '#999', 6);

// 创建一个按钮保存画布7
const saveBtn7 = document.createElement('button');
saveBtn7.innerText = '保存图像7';
saveBtn7.style.position = 'absolute';
saveBtn7.style.top = '160px';
saveBtn7.style.right = '10px';
document.body.appendChild(saveBtn7);
saveBtn7.onclick = function() {
    const link = document.createElement('a');
    link.download = 'cnn_structure7.png';
    link.href = canvas7.toDataURL();
    link.click();
  };
</script>

<script> // 第8个画布 Neck
  const canvas8 = document.getElementById('cnnCanvas8');
  const ctx8 = canvas8.getContext('2d');

  // 绘制 Neck 结构
  anchor_y1 = 70;
  anchor_y2 = 5;
  drawLabeledRoundedRectWithNumber(ctx8, 40, anchor_y1, 120, 20, 'UpSample', '', 'rgba(199, 255, 231, 0.4)', 4);
  drawLabeledRoundedRectWithNumber(ctx8, 40, anchor_y1 + 40, 120, 20, 'Concat', '', 'rgba(255, 239, 199, 0.6)', 4);
  drawLabeledRoundedRectWithNumber(ctx8, 40, anchor_y1 + 80, 120, 20, 'CSPLayer_2Conv', '', 'rgba(133, 237, 255, 0.4)', 4);
  drawLabeledRoundedRectWithNumber(ctx8, 40, anchor_y1 + 120, 120, 20, 'UpSample', '', 'rgba(199, 255, 231, 0.4)', 4);
  drawLabeledRoundedRectWithNumber(ctx8, 40, anchor_y1 + 160, 120, 20, 'Concat', '', 'rgba(255, 239, 199, 0.6)', 4);
  drawLabeledRoundedRectWithNumber(ctx8, 40, anchor_y1 + 200, 120, 20, 'CSPLayer_2Conv', '', 'rgba(133, 237, 255, 0.4)', 4);

  drawLabeledRoundedRectWithNumber(ctx8, 240, anchor_y2, 120, 20, 'CSPLayer_2Conv', '', 'rgba(133, 237, 255, 0.4)', 4);
  drawLabeledRoundedRectWithNumber(ctx8, 240, anchor_y2 + 40, 120, 20, 'Concat', '', 'rgba(255, 239, 199, 0.6)', 4);
  drawLabeledRoundedRectWithNumber(ctx8, 240, anchor_y2 + 80, 120, 20, 'ConvModule', '', 'rgba(180, 167, 215, 0.8)', 4);
  drawLabeledRoundedRectWithNumber(ctx8, 240, anchor_y2 + 120, 120, 20, 'CSPLayer_2Conv', '', 'rgba(133, 237, 255, 0.4)', 4);
  drawLabeledRoundedRectWithNumber(ctx8, 240, anchor_y2 + 160, 120, 20, 'Concat', '', 'rgba(255, 239, 199, 0.6)', 4);
  drawLabeledRoundedRectWithNumber(ctx8, 240, anchor_y2 + 200, 120, 20, 'ConvModule', '', 'rgba(180, 167, 215, 0.8)', 4);

  drawConnectorWithArrow(ctx8, 5, anchor_y1 + 170, 40, anchor_y1 + 170, '#000', 2, false, "", "12px sans-serif", "bottom");
  ctx8.fillStyle = '#000'; ctx8.font = '12px sans-serif';
  ctx8.fillText('P3', 5, anchor_y1 + 165);
  drawConnectorWithArrow(ctx8, 5, anchor_y1 + 50, 40, anchor_y1 + 50, '#000', 2, false, "", "12px sans-serif", "bottom");
  ctx8.fillText('P4', 5, anchor_y1 + 45);
  drawConnectorWithArrow(ctx8, 5, anchor_y2 + 50, 240, anchor_y2 + 50, '#000', 2, false, "", "12px sans-serif", "bottom");
  ctx8.fillText('P5 20x20x1024', 5, anchor_y2 + 45);
  
  drawConnectorWithArrow(ctx8, 100, anchor_y2 + 50, 100, anchor_y2 + 65, '#000', 2, false, "                                   20x20x1024", "12px sans-serif", "right");
  drawConnectorWithArrow(ctx8, 100, anchor_y2 + 85, 100, anchor_y2 + 105, '#000', 2, false, "                                   40x40x1024", "12px sans-serif", "right");
  drawConnectorWithArrow(ctx8, 100, anchor_y2 + 125, 100, anchor_y2 + 145, '#000', 2, false, "                                   40x40x1536", "12px sans-serif", "right");
  drawConnectorWithArrow(ctx8, 100, anchor_y2 + 165, 100, anchor_y2 + 185, '#000', 2, false, "                                   40x40x512", "12px sans-serif", "right");
  drawConnectorWithArrow(ctx8, 100, anchor_y2 + 205, 100, anchor_y2 + 225, '#000', 2, false, "                                   80x80x512", "12px sans-serif", "right");
  drawConnectorWithArrow(ctx8, 100, anchor_y2 + 245, 100, anchor_y2 + 265, '#000', 2, false, "                                   80x80x768", "12px sans-serif", "right");

  drawConnectorWithArrow(ctx8, 160, anchor_y2 + 275, 420, anchor_y2 + 275, '#000', 2, false, "", "12px sans-serif", "top");
  ctx8.fillText('P3 80x80x256', 380, anchor_y2 + 270);

  drawConnectorWithArrow(ctx8, 300, anchor_y2 + 275, 300, anchor_y2 + 220, '#000', 2, false, "                          80x80x256", "12px sans-serif", "top");
  drawConnectorWithArrow(ctx8, 300, anchor_y2 + 200, 300, anchor_y2 + 180, '#000', 2, false, "                          40x40x256", "12px sans-serif", "top");
  drawConnectorWithArrow(ctx8, 300, anchor_y2 + 160, 300, anchor_y2 + 140, '#000', 2, false, "                          40x40x768", "12px sans-serif", "top");
  drawConnectorWithArrow(ctx8, 300, anchor_y2 + 120, 300, anchor_y2 + 100, '#000', 2, false, "                          40x40x512", "12px sans-serif", "top");
  drawConnectorWithArrow(ctx8, 300, anchor_y2 + 80, 300, anchor_y2 + 60, '#000', 2, false, "                           20x20x512", "12px sans-serif", "top");
  drawConnectorWithArrow(ctx8, 300, anchor_y2 + 40, 300, anchor_y2 + 20, '#000', 2, false, "                             20x20x1536", "12px sans-serif", "top");

  drawConnectorWithArrow(ctx8, 360, anchor_y2 + 10, 420, anchor_y2 + 10, '#000', 2, false, "", "12px sans-serif", "top");
  ctx8.fillText('P3 20x20x1024', 380, anchor_y2 + 5);
  drawConnectorWithArrow(ctx8, 360, anchor_y2 + 130, 420, anchor_y2 + 130, '#000', 2, false, "", "12px sans-serif", "top");
  ctx8.fillText('P4 40x40x512', 380, anchor_y2 + 125);
  // 创建一个按钮保存画布8
  const saveBtn8 = document.createElement('button');
  saveBtn8.innerText = '保存图像8';
  saveBtn8.style.position = 'absolute';
  saveBtn8.style.top = '190px';
  saveBtn8.style.right = '10px';
  document.body.appendChild(saveBtn8);
  saveBtn8.onclick = function() {
      const link = document.createElement('a');
      link.download = 'cnn_structure8.png';
      link.href = canvas8.toDataURL();
      link.click();
    };
</script>
<script> // 第9个画布 YOLOv5和YOLOv8 Head对比
  const canvas9 = document.getElementById('cnnCanvas9');
  const ctx9 = canvas9.getContext('2d');

  // 在画布上绘制YOLOv5和YOLOv8 Head的对比
  // 模块
  drawLabeledRoundedRectWithNumber(ctx9, 30, 120, 80, 30, "Conv2d", "", 'rgba(199, 255, 231, 0.4)', 4);
  drawLabeledRoundedRectWithNumber(ctx9, 180, 60, 80, 30, "4", "", 'rgba(199, 255, 231, 0.4)', 4);
  ctx9.fillStyle = '#000'; ctx9.font = '14px sans-serif';
  ctx9.fillText('BBox CIoU', 265, 80);
  drawLabeledRoundedRectWithNumber(ctx9, 180, 120, 80, 30, "1", "", 'rgba(199, 255, 231, 0.4)', 4);
  ctx9.fillText('Obj BCE', 265, 140);
  drawLabeledRoundedRectWithNumber(ctx9, 180, 180, 80, 30, "1", "", 'rgba(199, 255, 231, 0.4)', 4);
  ctx9.fillText('Cls BCE', 265, 200);
  // 箭头
  drawConnectorWithArrow(ctx9, 10, 135, 30, 135, '#000', 2, false, "", "12px sans-serif", "bottom");

  drawConnectorWithArrow(ctx9, 140, 75, 180, 75, '#000', 2, false, "", "12px sans-serif", "bottom");
  drawConnectorWithArrow(ctx9, 110, 135, 180, 135, '#000', 2, false, "", "12px sans-serif", "bottom");
  drawConnectorWithArrow(ctx9, 140, 195, 180, 195, '#000', 2, false, "", "12px sans-serif", "bottom");
  drawConnectorReal(ctx9, 140, 75, 140, 195);

  drawLabeledRoundedRectWithNumber(ctx9, 420 - 10, 90, 60, 30, "Conv", "", 'rgba(199, 255, 231, 0.4)', 4);
  drawLabeledRoundedRectWithNumber(ctx9, 500 - 10, 90, 60, 30, "Conv", "", 'rgba(199, 255, 231, 0.4)', 4);
  drawLabeledRoundedRectWithNumber(ctx9, 580 - 10, 90, 60, 30, "Conv2d", "", 'rgba(199, 255, 231, 0.4)', 4);
  drawLabeledRoundedRectWithNumber(ctx9, 660 - 10, 90, 70, 30, "4xregmax", "", 'rgba(199, 255, 231, 0.4)', 4);
  ctx9.fillText('CIoU', 730, 110);
  ctx9.fillText('+DFL', 730, 130);

  drawLabeledRoundedRectWithNumber(ctx9, 420 - 10, 150, 60, 30, "Conv", "", 'rgba(199, 255, 231, 0.4)', 4);
  drawLabeledRoundedRectWithNumber(ctx9, 500 - 10, 150, 60, 30, "Conv", "", 'rgba(199, 255, 231, 0.4)', 4);
  drawLabeledRoundedRectWithNumber(ctx9, 580 - 10, 150, 60, 30, "Conv2d", "", 'rgba(199, 255, 231, 0.4)', 4);
  drawLabeledRoundedRectWithNumber(ctx9, 660 - 10, 150, 70, 30, "ncls", "", 'rgba(199, 255, 231, 0.4)', 4);
  ctx9.fillText('BCE', 730, 170);


  drawConnectorWithArrow(ctx9, 390 - 10, 105, 420 - 10, 105, '#000', 2, false, "", "12px sans-serif", "bottom");
  drawConnectorWithArrow(ctx9, 390 - 10, 165, 420 - 10, 165, '#000', 2, false, "", "12px sans-serif", "bottom");
  drawConnectorReal(ctx9, 390 - 10, 105, 390 - 10, 165);
  drawConnectorWithArrow(ctx9, 350, 135, 390 - 10, 135, '#000', 2, false, "", "12px sans-serif", "bottom");

  drawConnectorWithArrow(ctx9, 470, 105, 490, 105, '#000', 2, false, "", "12px sans-serif", "bottom");
  drawConnectorWithArrow(ctx9, 470, 165, 490, 165, '#000', 2, false, "", "12px sans-serif", "bottom");

  drawConnectorWithArrow(ctx9, 550, 105, 570, 105, '#000', 2, false, "", "12px sans-serif", "bottom");
  drawConnectorWithArrow(ctx9, 550, 165, 570, 165, '#000', 2, false, "", "12px sans-serif", "bottom");

  drawConnectorWithArrow(ctx9, 630, 105, 650, 105, '#000', 2, false, "", "12px sans-serif", "bottom");
  drawConnectorWithArrow(ctx9, 630, 165, 650, 165, '#000', 2, false, "", "12px sans-serif", "bottom");
  // 创建一个按钮保存画布9
  const saveBtn9 = document.createElement('button');
  saveBtn9.innerText = '保存图像9';
  saveBtn9.style.position = 'absolute';
  saveBtn9.style.top = '220px';
  saveBtn9.style.right = '10px';
  document.body.appendChild(saveBtn9);
  saveBtn9.onclick = function() {
      const link = document.createElement('a');
      link.download = 'cnn_structure9.png';
      link.href = canvas9.toDataURL();
      link.click();
    };


</script>


</body>
</html>