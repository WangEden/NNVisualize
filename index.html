<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>Canvas 绘制 CNN 结构图</title>
  <style>
    body { margin: 0; padding: 20px; background: #fff; }
    canvas { border: 1px solid #ccc; }
  </style>
</head>
<body>
<canvas id="cnnCanvas" width="780" height="240"></canvas>
<script>
  const canvas = document.getElementById('cnnCanvas');
  const ctx = canvas.getContext('2d');

  // 样式参数
  const fm1Color = 'rgba(0,100,255,0.2)';
  const convStroke = '#0060ff';
  const fm2Color = 'rgba(128,123,255,0.2)';
  const poolStroke = '#aa00aa';
  const dashColor = '#333';
  const dashColor2 = '#ff0';

  // 绘制多层叠加的方块函数
  function drawLayer(x, y, w, h, count, offset, fill, stroke, AlpghaRate) {
    for (let i = 0; i < count; i++) {
      // 保存当前状态
      ctx.save();
      // 逐层降低透明度
      ctx.globalAlpha = (1 - i / (count)) * AlpghaRate;
      ctx.fillStyle   = fill;
      ctx.strokeStyle = stroke;
      ctx.lineWidth   = 1;
      // 开始新路径并绘制圆角矩形
      ctx.beginPath();
      ctx.roundRect(x + i * offset, y + i * offset, w, h, 5);
      ctx.fill();
      ctx.stroke();
      // 恢复到 save() 时的状态（包括 globalAlpha）
      ctx.restore();
    }
  }

  // 绘制连线
  function drawConnector(fromX, fromY, toX, toY) {
    ctx.save();
    ctx.strokeStyle = dashColor;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = dashColor;
    ctx.fill();
    ctx.restore;
  }
  
  // 输入层
  const inputMap = { x: 20, y: 90, w: 50, h: 50, count: 3, off: 10 };
  drawLayer(inputMap.x, inputMap.y, inputMap.w, inputMap.h, inputMap.count, inputMap.off, fm1Color, convStroke, 3);
  ctx.fillStyle = '#222'; ctx.font = '14px sans-serif';
  ctx.fillText('输入层', inputMap.x, inputMap.y - 10);

  // 输入层选中区域
  const selInput = { x: inputMap.x + 4 * inputMap.off, y: inputMap.y + 4 * inputMap.off, w: 12, h: 12 };
  ctx.strokeStyle = dashColor2; ctx.setLineDash([3, 3]);
  ctx.strokeRect(selInput.x, selInput.y, selInput.w, selInput.h);
  ctx.setLineDash([]);

  // 特征图 1
  const fm1 = { x: 120, y: 50, w: 100, h: 100, count: 5, off: 10 };
  drawLayer(fm1.x, fm1.y, fm1.w, fm1.h, fm1.count, fm1.off, fm1Color, convStroke, 3);
  ctx.fillStyle = '#222'; ctx.font = '14px sans-serif';
  ctx.fillText('特征图 1', fm1.x, fm1.y - 10);

  // 输入层到特征图1的连线
  const fromX1Input = selInput.x + selInput.w;
  const fromY1Input = selInput.y;
  const fromX2Input = selInput.x + selInput.w;
  const fromY2Input = selInput.y + selInput.h;
  drawConnector(fromX1Input, fromY1Input, fm1.x + 9 * fm1.off, fm1.y + 9 * fm1.off);
  drawConnector(fromX2Input, fromY2Input, fm1.x + 9 * fm1.off, fm1.y + 9 * fm1.off);
  // 在连线下方添加文字
  ctx.fillStyle = '#222'; ctx.font = '14px sans-serif';
  ctx.fillText('卷积', (fromX1Input + fm1.x + 1 * fm1.off) / 2 - 10, (fromY1Input + fm1.y) - 10);

  // 特征图 1 选中区域（虚线框）
  const sel1 = { x: fm1.x + 7 * fm1.off, y: fm1.y + 7 * fm1.off, w: 25, h: 25};
  ctx.strokeStyle = dashColor2; ctx.setLineDash([3, 3]);
  ctx.strokeRect(sel1.x, sel1.y, sel1.w, sel1.h);
  ctx.setLineDash([]);

  // 特征图 2
  const fm2 = { x: 290, y: 70, w: 60, h: 60, count: 5, off: 8 };
  drawLayer(fm2.x, fm2.y, fm2.w, fm2.h, fm2.count, fm2.off, fm2Color, poolStroke, 3);
  ctx.fillStyle = '#222'; ctx.font = '14px sans-serif';
  ctx.fillText('特征图 2', fm2.x, fm2.y - 10);

  // 特征图 2 选中区域
  const sel2 = { x: fm2.x + 7 * fm2.off, y: fm2.y + 5 * fm2.off, w: 15, h: 15 };
  ctx.strokeStyle = dashColor2; ctx.setLineDash([3, 3]);
  ctx.strokeRect(sel2.x, sel2.y, sel2.w, sel2.h);
  ctx.setLineDash([]);

  // 从特征图1选中到特征图2的连线,双线汇于一点，起点为右上角和右下角
  const fromX1Sel1 = sel1.x + sel1.w;
  const fromY1Sel1 = sel1.y;
  const fromX2Sel1 = sel1.x + sel1.w;
  const fromY2Sel1 = sel1.y + sel1.h;
  const toX = fm2.x + 8 * fm2.off;
  const toY = fm2.y + 6 * fm2.off;
  drawConnector(fromX1Sel1, fromY1Sel1, toX, toY);
  drawConnector(fromX2Sel1, fromY2Sel1, toX, toY);
  // 在连线下方添加文字
  ctx.fillStyle = '#222'; ctx.font = '14px sans-serif';
  ctx.fillText('池化', (fromX1Sel1 + fm2.x + 3 * fm2.off) / 2, (fromY1Sel1 + fm2.y) - 30);

  // 特征图 3
  const fm3 = { x: 390, y: 50, w: 70, h: 70, count: 12, off: 8 };
  drawLayer(fm3.x, fm3.y, fm3.w, fm3.h, fm3.count, fm3.off, fm1Color, convStroke, 9);
  ctx.fillStyle = '#222'; ctx.font = '14px sans-serif';
  ctx.fillText('特征图 3', fm3.x, fm3.y - 10);

  // 特征图 3 选中区域
  const sel3 = { x: fm3.x + 15 * fm3.off, y: fm3.y + 14 * fm3.off, w: 15, h: 15 };
  ctx.strokeStyle = dashColor2; ctx.setLineDash([3, 3]);
  ctx.strokeRect(sel3.x, sel3.y, sel3.w, sel3.h);
  ctx.setLineDash([]);

  // 从特征图2选中到特征图3的连线,双线汇于一点，起点为右上角和右下角
  const fromX1Sel2 = sel2.x + sel2.w;
  const fromY1Sel2 = sel2.y;
  const fromX2Sel2 = sel2.x + sel2.w;
  const fromY2Sel2 = sel2.y + sel2.h;
  drawConnector(fromX1Sel2, fromY1Sel2, fm3.x + 16 * fm3.off, fm3.y + 15 * fm3.off);
  drawConnector(fromX2Sel2, fromY2Sel2, fm3.x + 16 * fm3.off, fm3.y + 15 * fm3.off);
  // 在连线下方添加文字
  ctx.fillStyle = '#222'; ctx.font = '14px sans-serif';
  ctx.fillText('卷积', (fromX1Sel2 + fm3.x + 4 * fm3.off) / 2, (fromY1Sel2 + fm3.y));

  // 特征图 4
  const fm4 = { x: 525, y: 70, w: 40, h: 40, count: 12, off: 8 };
  drawLayer(fm4.x, fm4.y, fm4.w, fm4.h, fm4.count, fm4.off, fm2Color, poolStroke, 9);
  ctx.fillStyle = '#222'; ctx.font = '14px sans-serif';
  ctx.fillText('特征图 4', fm4.x, fm4.y - 10);

  // 特征图3选中区域到特征图4选中区域的连线
  const fromX1Sel3 = sel3.x + sel3.w;
  const fromY1Sel3 = sel3.y;
  const fromX2Sel3 = sel3.x + sel3.w;
  const fromY2Sel3 = sel3.y + sel3.h;
  const toX2 = fm4.x + 13 * fm4.off;
  const toY2 = fm4.y + 13 * fm4.off;
  drawConnector(fromX1Sel3, fromY1Sel3, toX2, toY2);
  drawConnector(fromX2Sel3, fromY2Sel3, toX2, toY2);
  // 在连线下方添加文字
  ctx.fillStyle = '#222'; ctx.font = '14px sans-serif';
  ctx.fillText('池化', (fromX1Sel3 + fm4.x + 7 * fm4.off) / 2, (fromY1Sel3 + fm4.y) - 35);

  // 全连接层
  const fc = { x: 620, y: 90, count: 10, space: 10, r: 8 };
  ctx.fillStyle = '#222'; ctx.font = '14px sans-serif';
  ctx.fillText('全连接层', fc.x, fc.y - 20);
  for (let i = 0; i < fc.count; i++) {
    ctx.beginPath();
    ctx.fillStyle = 'rgba(128,222,233,0.8)';
    ctx.strokeStyle = 'purple';
    ctx.lineWidth = 1;
    ctx.arc(fc.x + i * fc.space, fc.y + i * fc.space, fc.r, 0, 2 * Math.PI);
    ctx.fill(); ctx.stroke();
  }

  // 特征图 3 到全连接层的连线
  const fromX1Fm4 = fm4.x + fm4.w;
  const fromY1Fm4 = fm4.y;
  const fromX2Fm4 = fm4.x + fm4.w + (fm4.count - 1) * fm4.off;
  const fromY2Fm4 = fm4.y + fm4.h + (fm4.count - 1) * fm4.off;
  drawConnector(fromX1Fm4, fromY1Fm4, fc.x, fc.y);
  drawConnector(fromX2Fm4, fromY2Fm4, fc.x + (fc.count - 1) * fc.space, fc.y + (fc.count - 1) * fc.space);

  // 输出层
  const outX = fc.x + (fc.count - 1) * fc.space + 10;
  const outY = fc.y + (fc.count / 2) * fc.space;
  ctx.fillStyle = '#222'; ctx.font = '14px sans-serif';
  ctx.fillText('输出层', outX, outY - 20);
  ctx.beginPath();
  // 浅蓝色
  ctx.fillStyle = 'rgba(128,222,233,0.8)'; ctx.strokeStyle = 'purple';
  ctx.arc(outX + 20, outY, fc.r, 0, 2 * Math.PI);
  ctx.fill(); ctx.stroke();

  // 连接到输出层
  const fromX1Fc = fc.x;
  const fromY1Fc = fc.y;
  const fromX2Fc = fc.x + (fc.count - 1) * fc.space;
  const fromY2Fc = fc.y + (fc.count - 1) * fc.space;
  drawConnector(fromX1Fc, fromY1Fc, outX + 20, outY);
  drawConnector(fromX2Fc, fromY2Fc, outX + 20, outY);

  // 创建按钮保存以上绘制的图像
  const saveBtn = document.createElement('button');
  saveBtn.innerText = '保存图像';
  saveBtn.style.position = 'absolute';
  saveBtn.style.top = '10px';
  saveBtn.style.right = '10px';
  saveBtn.onclick = function() {
    const link = document.createElement('a');
    link.download = 'cnn_structure.png';
    link.href = canvas.toDataURL();
    link.click();
  };
  document.body.appendChild(saveBtn);
</script>
</body>
</html>